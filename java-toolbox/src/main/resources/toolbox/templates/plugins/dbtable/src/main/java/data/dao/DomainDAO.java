<#assign keyField = domain.keyFields?first>
<#assign rowMapperClassName = domain.className + "RowMapper">
package ${dao.packageName};

import ${domain.packageName}.*;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;

/**
 * A DAO to access ${dao.domain.className} domain.
 *
 * This class is generated by Zemian's CodeGen Toolbox on ${todayDt?date}.
 */
@Repository
public class ${dao.className} extends AbstractDAO {
    public static class ${rowMapperClassName} implements RowMapper<${domain.className}> {
        @Override
        public ${domain.className} mapRow(ResultSet rs, int rowNum) throws SQLException {
            ${domain.className} ret = new ${domain.className}();
            <#list domain.fields as field>
            <#if field.type == 'java.time.LocalDateTime'>
            <#if field.dbField.nullable>
            ret.${field.setterMethodName}((rs.getTimestamp("${field.dbField.columnName}") != null) ? rs.getTimestamp("${field.dbField.columnName}").toLocalDateTime() : null);
            <#else>
            ret.${field.setterMethodName}(rs.getTimestamp("${field.dbField.columnName}").toLocalDateTime());
            </#if>
            <#elseif field.type?starts_with(domain.className + '.')>
            ret.${field.setterMethodName}(${field.type}.valueOf(rs.getString("${field.dbField.columnName}")));
            <#else>
            ret.${field.setterMethodName}((${field.type}) rs.getObject("${field.dbField.columnName}"));
            </#if>
            </#list>
            return ret;
        }
    }

    private static Logger LOG = LoggerFactory.getLogger(${dao.className}.class);

    public void create(${domain.className} ${domain.classVar}) {
        <#if keyField.dbField.autoincrement>
        String sql = "INSERT INTO ${dbTable.tableName}(${domain.nonKeyDbFieldNames}) VALUES(${domain.nonKeyQMarks})";
        KeyHolder keyHolder = new GeneratedKeyHolder();
        int ret = jdbc.update((conn) -> {
            PreparedStatement pstmt = conn.prepareStatement(sql, PreparedStatement.RETURN_GENERATED_KEYS);
            int idx = 1;
            <#list domain.nonKeyFields as field>
            <#if field.type?starts_with(domain.className + '.')>
            pstmt.setObject(idx++, ${domain.classVar}.${field.getterMethodName}().name());
            <#else>
            pstmt.setObject(idx++, ${domain.classVar}.${field.getterMethodName}());
            </#if>
            </#list>
            return pstmt;
        }, keyHolder);

        // Retrieve and save the generate key
        ${domain.classVar}.${keyField.setterMethodName}((${keyField.type})keyHolder.getKeys().get("${keyField.dbField.columnName}"));
        LOG.info("Inserted {}, result={}", ${domain.classVar}, ret);
        <#else>
        String sql = "INSERT INTO ${dbTable.tableName}(${domain.dbFieldNames}) VALUES(${domain.dbFieldQMarks})";
        int ret = jdbc.update((conn) -> {
            PreparedStatement pstmt = conn.prepareStatement(sql);
            int idx = 1;
            <#list domain.fields as field>
                <#if field.type?starts_with(domain.className + '.')>
            pstmt.setObject(idx++, ${domain.classVar}.${field.getterMethodName}().name());
                <#else>
            pstmt.setObject(idx++, ${domain.classVar}.${field.getterMethodName}());
                </#if>
            </#list>
            return pstmt;
        });

        LOG.info("Inserted {}, result={}", ${domain.classVar}, ret);
        </#if>
    }

    public void update(${domain.className} ${domain.classVar}) {
        String sql = "UPDATE ${dbTable.tableName} SET" +
            <#list domain.nonKeyFields as field>" ${field.dbField.columnName} = ?<#sep>," +
            </#list>" +
            " WHERE ${keyField.dbField.columnName} = ?";
        int ret = jdbc.update(sql,
            <#list domain.nonKeyFields as field><#if field.type?starts_with(domain.className + '.')>${domain.classVar}.${field.getterMethodName}().name() <#else>${domain.classVar}.${field.getterMethodName}()</#if><#sep>,
            </#list>,
            ${domain.classVar}.${keyField.getterMethodName}());
        LOG.debug("Updated {}, result={}", ${domain.classVar}, ret);
    }

    public ${domain.className} get(${keyField.type} ${keyField.name}) {
        String sql = "SELECT * FROM ${dbTable.tableName} WHERE ${keyField.dbField.columnName} = ?";
        return jdbc.queryForObject(sql, new ${rowMapperClassName}(), ${keyField.name});
    }

    public void delete(${keyField.type} ${keyField.name}) {
        int ret = jdbc.update("DELETE FROM ${dbTable.tableName} WHERE ${keyField.dbField.columnName} = ?", ${keyField.name});
        LOG.debug("Deleted ${domain.className} ${keyField.name}={}, result={}", ${keyField.name}, ret);
    }

    public boolean exists(${keyField.type} ${keyField.name}) {
        String sql = "SELECT EXISTS(SELECT ${keyField.dbField.columnName} FROM ${dbTable.tableName} WHERE ${keyField.dbField.columnName} = ?)";
        return jdbc.queryForObject(sql, Boolean.class, ${keyField.name});
    }

    public List<${domain.className}> findAll() {
        String sql = "SELECT * FROM ${dbTable.tableName} ORDER BY ${keyField.dbField.columnName}";
        return jdbc.query(sql, new ${rowMapperClassName}());
    }

    public PagingList<${domain.className}> find(Paging paging) {
        String sql = "SELECT * FROM ${dbTable.tableName} ORDER BY ${keyField.dbField.columnName}";
        return findByPaging(sql, new ${rowMapperClassName}(), paging);
    }
}
